# selector/auto_selector.py
from typing import List, Dict, Tuple
import os
import pandas as pd
from engine.datafeed import add_indicators
from engine.risk import default_sl_target

def score_intraday(df: pd.DataFrame) -> float:
    if df.empty: return -1e9
    atrp = (df["atr"].iloc[-1] / df["close"].iloc[-1]) * 100
    adx = df["adx"].iloc[-1]
    mom = (df["ema_fast"].iloc[-1] - df["ema_slow"].iloc[-1]) / df["close"].iloc[-1] * 100
    vol = df["volume"].rolling(20).mean().iloc[-1] if "volume" in df and len(df) >= 20 else 0
    # Weighted score: volatility (atr%), trend strength (adx), momentum
    return 0.45 * atrp + 0.35 * adx + 0.15 * mom + 0.05 * (vol / 1e5)

def score_swing(df: pd.DataFrame) -> float:
    if df.empty: return -1e9
    adx = df["adx"].iloc[-1]
    slope = (df["ema_fast"].iloc[-1] / df["ema_fast"].iloc[-10] - 1.0) * 100 if len(df) > 10 else 0
    trend_gap = (df["ema_fast"].iloc[-1] - df["ema_slow"].iloc[-1]) / df["close"].iloc[-1] * 100
    return 0.5 * adx + 0.3 * slope + 0.2 * trend_gap

def choose_mode_now(now_ist):
    hm = now_ist.hour*100 + now_ist.minute
    return "intraday" if 915 <= hm <= 1530 else "swing"
    #return "intraday"

def pick_preferred_intraday_interval(df_5m: pd.DataFrame, df_15m: pd.DataFrame, cfg: Dict) -> str:
    """Heuristic: choose 5-min if ATR% on 5-min >= threshold, else 15-min."""
    threshold = cfg.get("intraday_vol_threshold_pct", 0.35)
    if df_5m is None or df_15m is None:
        return "FIFTEEN_MINUTE"
    if df_5m.empty and df_15m.empty:
        return "FIFTEEN_MINUTE"
    if df_5m.empty:
        return "FIFTEEN_MINUTE"
    if df_15m.empty:
        return "FIVE_MINUTE"

    atr5 = df_5m["atr"].iloc[-1] if "atr" in df_5m.columns else 0
    atr15 = df_15m["atr"].iloc[-1] if "atr" in df_15m.columns else 0
    close5 = df_5m["close"].iloc[-1] if "close" in df_5m.columns else 0
    close15 = df_15m["close"].iloc[-1] if "close" in df_15m.columns else 0
    atr5p = (atr5 / close5) * 100 if close5 and atr5 else 0
    atr15p = (atr15 / close15) * 100 if close15 and atr15 else 0

    if atr5p >= threshold:
        return "FIVE_MINUTE"
    return "FIFTEEN_MINUTE"

def llm_rerank(candidates: List[Tuple[str,float]], prompt_context: str, cfg: Dict) -> List[str]:
    """Rerank top candidates using an LLM if enabled. Expects cfg keys: enabled, provider, api_key_env, model, temperature, max_symbols
    Returns list of symbols in new order. If LLM not available or fails, returns original order.
    """
    if not cfg.get("enabled", False):
        return [s for s, _ in candidates]

    provider = cfg.get("provider", "openai")
    api_env = cfg.get("api_key_env", "OPENAI_API_KEY")
    api_key = os.getenv(api_env, "")
    topk = cfg.get("max_symbols", 10)
    tops = candidates[:topk]
    symbols = [s for s, _ in tops]

    if not api_key:
        # no key available; return original ordering
        return symbols

    # Build a compact prompt describing each candidate's score
    prompt_lines = [f"Rank these symbols from best to worst for {prompt_context}. Provide only the ranked list in CSV order.\n"]
    for s, sc in tops:
        prompt_lines.append(f"{s}: score={sc:.4f}")
    prompt = "\n".join(prompt_lines)

    # Call OpenAI chat completion (if provider=openai)
    try:
        if provider == "openai":
            try:
                import openai
            except Exception:
                return symbols
            openai.api_key = api_key
            model = cfg.get("model", "gpt-4o-mini")
            resp = openai.ChatCompletion.create(
                model=model,
                messages=[
                    {"role":"system","content":"You are an expert quant trader. Rank symbols by short-term tradability and momentum."},
                    {"role":"user","content": prompt}
                ],
                temperature=float(cfg.get("temperature", 0.2)),
                max_tokens=200
            )
            txt = resp["choices"][0]["message"]["content"].strip()
            # Extract symbols in order by reading CSV-like tokens
            out = []
            for part in txt.replace('\n',',').split(','):
                token = part.strip().split()[0].strip()
                if token in symbols and token not in out:
                    out.append(token)
            if len(out) >= 1:
                return out
    except Exception:
        return symbols
    return symbols

def build_trade_plan(symbol: str, df: pd.DataFrame, cfg: Dict):
    """

    Returns a dict containing: symbol, price, stop_price, target_price, stop_dist, rr
    Requires df to contain indicators (atr, ema_fast, ema_slow).
    """
    if df is None or df.empty:
        return None
    price = float(df["close"].iloc[-1])
    atr = float(df["atr"].iloc[-1]) if "atr" in df.columns else max(0.25, price*0.005)
    atr_mult = cfg.get("strategy", {}).get("atr_mult", 2.0)
    rr = cfg.get("strategy", {}).get("rr", 2.0)
    min_stop = cfg.get("strategy", {}).get("min_stop_abs", 0.5)
    stop_price, target_price, stop_dist = default_sl_target(price, atr, atr_mult=atr_mult, rr=rr, min_stop_abs=min_stop)

    plan = dict(
        symbol=symbol,
        price=price,
        stop_price=stop_price,
        target_price=target_price,
        stop_dist=stop_dist,
        rr=rr
    )
    return plan
