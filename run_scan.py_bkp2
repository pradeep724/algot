"""
run_scan.py
------------
Scan your universe and auto-pick symbols for intraday or swing.
Builds trade plans with preferred timeframe, default SL and targets and qty.
- Fetches candles from AngelOne API (live) or from CSV (backtest mode).
- Stores candles and trade plans into CSVs for future backtesting.
"""

import os
import pandas as pd
from datetime import datetime, timedelta

from engine.utils import load_config, load_universe
from engine.datafeed import add_indicators, candles_to_df
from selector.auto_selector import (
    score_intraday,
    score_swing,
    choose_mode_now,
    pick_preferred_intraday_interval,
    llm_rerank,
    build_trade_plan,
)
from engine.risk import position_size
from engine.broker_angel import AngelBroker


def fetch_history_for_interval(symbol, interval, cfg, backtest=False):
    """
    Fetch candles for given symbol/interval.
    - If backtest=True, read from local CSV.
    - Otherwise fetch from AngelOne API and save CSV copy.
    """
    tradingsymbol = symbol["tradingsymbol"]
    token = symbol["symboltoken"]

    # Path for caching CSV
    data_dir = os.path.join("data", "candles")
    os.makedirs(data_dir, exist_ok=True)
    csv_path = os.path.join(data_dir, f"{tradingsymbol}_{interval}.csv")

    if backtest and os.path.exists(csv_path):
        df = pd.read_csv(csv_path, parse_dates=["timestamp"], index_col="timestamp")
        return df

    # --- Live fetch from AngelOne ---
    broker = AngelBroker(
        cfg["broker"]["api_key"],
        cfg["broker"]["client_id"],
        cfg["broker"]["password"],
        cfg["broker"]["totp_secret"],
    )
    to_date = datetime.now()
    from_date = to_date - timedelta(days=30 if interval != "ONE_DAY" else 365)

    try:
        candles = broker.getCandleData(
            token=token,
            interval=interval,
            from_date=from_date.strftime("%Y-%m-%d %H:%M"),
            to_date=to_date.strftime("%Y-%m-%d %H:%M"),
        )
        df = candles_to_df(candles)
        if df.empty:
            return pd.DataFrame()
        # Save to CSV
        df.to_csv(csv_path)
        return df
    except Exception as e:
        print(f"Error fetching {tradingsymbol} {interval}: {e}")
        return pd.DataFrame()


if __name__ == "__main__":
    cfg = load_config()
    universe = load_universe(cfg["run"]["universe_csv"])
    now = datetime.now()
    mode = choose_mode_now(now)
    backtest_mode = cfg["run"].get("backtest", False)

    print(f"Mode now: {mode.upper()} at {now}, backtest={backtest_mode}")

    scored = []
    trade_plans = []

    for sym in universe:
        if mode == "intraday":
            df5 = fetch_history_for_interval(sym, "FIVE_MINUTE", cfg, backtest=backtest_mode)
            if df5 is not None and not df5.empty:
                df5 = add_indicators(df5, fast=cfg["strategy"]["fast"], slow=cfg["strategy"]["slow"], atr_period=cfg["strategy"]["atr_period"])

            df15 = fetch_history_for_interval(sym, "FIFTEEN_MINUTE", cfg, backtest=backtest_mode)
            if df15 is not None and not df15.empty:
                df15 = add_indicators(df15, fast=cfg["strategy"]["fast"], slow=cfg["strategy"]["slow"], atr_period=cfg["strategy"]["atr_period"])

            pref_interval = pick_preferred_intraday_interval(df5, df15, cfg["scan"])
            df = df5 if pref_interval == "FIVE_MINUTE" else df15
            score = score_intraday(df) if not df.empty else -1e9

        else:  # swing
            df = fetch_history_for_interval(sym, "ONE_DAY", cfg, backtest=backtest_mode)
            if df is not None and not df.empty:
                df = add_indicators(df, fast=cfg["strategy"]["fast"], slow=cfg["strategy"]["slow"], atr_period=cfg["strategy"]["atr_period"])
            score = score_swing(df) if not df.empty else -1e9
            pref_interval = "ONE_DAY"

        if df is None or df.empty:
            continue

        scored.append((sym, float(score), pref_interval, df))

    # sort and pick top-N
    top_n = cfg["scan"]["intraday_top_n"] if mode == "intraday" else cfg["scan"]["swing_top_n"]
    scored.sort(key=lambda x: x[1], reverse=True)
    top = scored[:top_n]

    # optional LLM-based re-rank (cfg['llm'])
    top_symbols = llm_rerank([(s, sc) for s, sc, _, _ in top], prompt_context=f"mode={mode}", cfg=cfg["llm"])
    print("Top symbols selected:", [t[0] for t in top])

    # build trade plans for top symbols using their df and default SL/Targets
    for sym, score, pref_interval, df in top:
        plan = build_trade_plan(sym, df, cfg)
        if plan:
            total_cap = cfg["run"]["capital"]
            reserved = cfg["run"].get("reserved_ratio", 0.20)
            qty = position_size(total_cap, plan["price"], cfg["run"]["risk_per_trade"], plan["stop_dist"], reserved_ratio=reserved)
            plan["qty"] = qty
            plan["interval"] = pref_interval
            plan["score"] = score
            plan["timestamp"] = now.strftime("%Y-%m-%d %H:%M")
            trade_plans.append(plan)

    print("Trade plans (top):")
    for p in trade_plans:
        print(p)

    # --- Save trade plans to CSV ---
    out_dir = os.path.join("data", "trade_plans")
    os.makedirs(out_dir, exist_ok=True)
    out_file = os.path.join(out_dir, f"{now.strftime('%Y%m%d_%H%M')}_{mode}.csv")
    pd.DataFrame(trade_plans).to_csv(out_file, index=False)
    print(f"Trade plans saved to {out_file}")
